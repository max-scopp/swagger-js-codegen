
/**
* Returns a fully constructed URL, including all query params for GET.
* @see {{&methodName}}
* @method
{{#isDeprecated}}
* @deprecated
{{/isDeprecated}}
*/
public {{&methodName}}URL(parameters: {
{{#parameters}}{{^isSingleton}}'{{&camelCaseName}}'{{&cardinality}}: {{> type}},
{{/isSingleton}}{{/parameters}}
} & CommonRequestOptions): string {
    const {path: originalPath, params, body: getBody, form, required: requiredParams} = {{className}}.entries[{{position}}];
    const discardParameters = {{^isBodyParameter}}{{#isPOST}}true{{/isPOST}}{{^isPOST}}false{{/isPOST}}{{/isBodyParameter}};

    const prefferedPath = (typeof(parameters.$path) === 'function') ?
        parameters.$path(originalPath) : parameters.$path;

    const $queryParameters = parameters.$queryParameters;

    const domain = parameters.$domain || this.domain;
    const url = new URL(domain + (prefferedPath || originalPath));
    const sp = url.searchParams;

    if(!discardParameters) {
        {{#parameters}}
            {{#isQueryParameter}}
                const {{camelCaseName}} = params['{{&name}}'];

                {{#isSingleton}}
                    sp.set('{{&name}}', {{camelCaseName}});
                {{/isSingleton}}
                {{^isSingleton}}
                    {{#isPatternType}}
                        const matches = Object.keys(params)
                            .filter(parameterName => {{camelCaseName}}.test(parameterName));

                        matches.forEach(match =>
                            sp.append('{{name}}', match)
                        );
                    {{/isPatternType}}
                    {{^isPatternType}}
                        if(typeof {{camelCaseName}} === 'function') {
                            const has_{{camelCaseName}} = {{camelCaseName}}(parameters);
                            if(has_{{camelCaseName}} !== undefined){
                                sp.set('{{&name}}', has_{{camelCaseName}});
                            }
                        } else {
                            this.isUnexpected('Expected "{{&name}}" of type `(parameters) => "{{&camelCaseName}}"`, but is of type: ' + typeof  {{camelCaseName}});
                        }
                    {{/isPatternType}}
                {{/isSingleton}}
            {{/isQueryParameter}}

            {{#isPathParameter}}
                url.pathname = String(url.pathname)
                    .replace('{{&name}}', params['{{&name}}'](parameters));
            {{/isPathParameter}}
        {{/parameters}}


        if ($queryParameters && Object.keys($queryParameters).length) {
            Object.entries($queryParameters)
                .forEach(([$key, $param]) => {
                    sp.set($key, $param);
                })
        }
    }

    return url.toString();
}

/**
* {{&summary}}
* @method
{{#isDeprecated}}
* @deprecated
{{/isDeprecated}}
{{#externalDocs}}
* @see {@link {{&url}}|{{#description}}{{&description}}{{/description}}{{^description}}External docs{{/description}}}
{{/externalDocs}}
* @name {{&className}}#{{&methodName}}
{{#parameters}}
    {{^isSingleton}} * @param {{=<% %>=}}{<%&type%>}<%={{ }}=%> {{&camelCaseName}} - {{&description}}{{/isSingleton}}isBodyParameter
{{/parameters}}
*/
public {{&methodName}}(parameters: {
{{#parameters}}{{^isSingleton}}'{{&camelCaseName}}'{{&cardinality}}: {{> type}},
{{/isSingleton}}{{/parameters}}
    $queryParameters?: any,
    $domain?: string,
    $path?: string | ((path: string) => string)
}): Promise<{{&responseTypes}}> {
    const {path: originalPath, method, params, headers: _headers, body: getBody, form: formParam, required: requiredParams} = {{className}}.entries[{{position}}];

    // will be overwritten if `discardParameters`
    let url = new URL(this.{{&methodName}}URL(parameters));
    const sp = url.searchParams;

    const discardParameters = {{^isBodyParameter}}{{#isPOST}}true{{/isPOST}}{{^isPOST}}false{{/isPOST}}{{/isBodyParameter}};

    return new Promise((resolve, reject) => {
const $queryParameters = parameters.$queryParameters;

let body;
const headers = new Headers(_headers || {});
const form = new FormData();

if(!discardParameters) {
{{#parameters}}

    {{#required}}
        if(parameters['{{&name}}'] === undefined) {
            reject(new Error('Missing required {{&paramType}} parameter: "{{&camelCaseName}}"'));
            return;
        }
    {{/required}}

    {{#isBodyParameter}}
        body = getBody(parameters);
    {{/isBodyParameter}}

    {{#isFormParameter}}
        {{#isSingleton}}
            form.append('{{&name}}', formParam['{{&name}}'] as string);
        {{/isSingleton}}
        {{^isSingleton}}
            typeof formParam['{{&name}}'] === 'function' && form.append('{{&name}}', formParam['{{&name}}'](parameters));
        {{/isSingleton}}
    {{/isFormParameter}}

{{/parameters}}

        if ($queryParameters && Object.keys($queryParameters).length) {
            Object.entries($queryParameters)
                .forEach(([$key, $param]) => {
                    // not sure why he doesn't know that $param should be a string
                    sp.set($key, $param as string);
                })
        }

    } else {
        // for some odd reason does searchParams prefer value over it's name (key)
        url.searchParams.forEach((value, name) => {
            form.append(name, value);
        });

        url.search = '';
    }

    let hasForm = false;

    (form as any).keys().next(({value, done}) => value ? hasForm = true : void 0);

    if(hasForm) {
        body = form;
    }

    this.request<{{&responseTypes}}>(method, {{&model}} , url.toString(), body, headers, reject, resolve);
});
}
