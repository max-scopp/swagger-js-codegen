
/**
* Returns a fully constructed URL, including all query params for GET.
* @see {{&methodName}}
* @method
{{#isDeprecated}}
* @deprecated
{{/isDeprecated}}
*/
public {{&methodName}}URL(parameters: {
{{#parameters}}{{^isSingleton}}'{{&camelCaseName}}'{{&cardinality}}: {{> type}},
{{/isSingleton}}{{/parameters}}
} & CommonRequestOptions): string {
    const {path: originalPath, params, body: getBody, form, required: requiredParams} = {{className}}.entries[{{position}}];
    const discardParameters = {{^isBodyParameter}}{{#isPOST}}true{{/isPOST}}{{^isPOST}}false{{/isPOST}}{{/isBodyParameter}};

    const prefferedPath = (typeof(parameters.$path) === 'function') ?
        parameters.$path(originalPath) : parameters.$path;

    const $queryParameters = parameters.$queryParameters;

    const domain = parameters.$domain || this.domain;
    const url = new URL(domain + (prefferedPath || originalPath), location.origin);
    const sp = url.searchParams;
    let realPath = decodeURIComponent(url.pathname)

    if(!discardParameters) {
        {{#parameters}}
            {{#isQueryParameter}}
                const {{camelCaseName}} = params['{{&name}}'];

                {{#isSingleton}}
                    sp.set('{{camelCaseName}}', {{camelCaseName}});
                {{/isSingleton}}
                {{^isSingleton}}
                    {{#isPatternType}}
                        const matches = Object.keys(params)
                            .filter(parameterName => {{camelCaseName}}.test(parameterName));

                        matches.forEach(match =>
                            sp.append('{{camelCaseName}}', match)
                        );
                    {{/isPatternType}}
                    {{^isPatternType}}
                        if(typeof {{camelCaseName}} === 'function') {
                            const has_{{camelCaseName}} = {{camelCaseName}}(parameters);
                            if(has_{{camelCaseName}} !== undefined){
                                sp.set('{{camelCaseName}}', has_{{camelCaseName}});
                            }
                        } else {
                            this.isUnexpected('Expected "{{&name}}" of type `(parameters) => "{{&camelCaseName}}"`, but is of type: ' + typeof  {{camelCaseName}});
                        }
                    {{/isPatternType}}
                {{/isSingleton}}
            {{/isQueryParameter}}

            {{#isPathParameter}}
                realPath = realPath
                    .replace(
                        '{{=<% %>=}}{<%&name%>}<%={{ }}=%>', String(
                            typeof params['{{&name}}'] === "function" 
                                ? (params['{{&name}}'] as Function)(parameters)
                                : params['{{&name}}']
                        ));
            {{/isPathParameter}}
        {{/parameters}}


        if ($queryParameters && Object.keys($queryParameters).length) {
            Object.entries($queryParameters)
                .forEach(([$key, $param]) => {
                    sp.set($key, $param);
                })
        }
    }

    url.pathname = realPath;

    return url.toString();
}

/**
* {{&summary}}
* @method
{{#isDeprecated}}
* @deprecated
{{/isDeprecated}}
{{#externalDocs}}
* @see {@link {{&url}}|{{#description}}{{&description}}{{/description}}{{^description}}External docs{{/description}}}
{{/externalDocs}}
* @name {{&className}}#{{&methodName}}
{{#parameters}}
    {{^isSingleton}} * @param {{=<% %>=}}{<%&type%>}<%={{ }}=%> {{&camelCaseName}} - {{&description}}{{/isSingleton}}isBodyParameter
{{/parameters}}
*/
public {{&methodName}}(_parameters: {
{{#parameters}}{{^isSingleton}}'{{&camelCaseName}}'{{&cardinality}}: {{> type}},
{{/isSingleton}}{{/parameters}}
    $queryParameters?: any,
    $domain?: string,
    $path?: string | ((path: string) => string)
}): Promise<{{&responseTypes}}> {
    const {path: originalPath, method, params, headers: _headers, body: getBody, form: formParam, required: requiredParams} = {{className}}.entries[{{position}}];

    let url = new URL(this.{{&methodName}}URL(_parameters));
    const sp = url.searchParams;

    const parameters = {...params, ..._parameters}
    
    return new Promise((resolve, reject) => {
const $queryParameters = _parameters.$queryParameters;

let body;

const useHeaders = Object.entries({
    ...this.headers,
    ...(_headers || {})
}).map(([name, header]) => {
    return [
        name,
        typeof header === 'function' ? header(parameters) : header
    ]
})
const headers = new Headers(useHeaders);
const form = new FormData();


{{#isBodyParameter}}
    body = getBody(parameters);
{{/isBodyParameter}}

{{#parameters}}

    {{#required}}
        if(parameters['{{&name}}'] === undefined) {
            reject(new Error('Missing required {{&paramType}} parameter: "{{&camelCaseName}}"'));
            return;
        }
    {{/required}}
    {{#isFormParameter}}
        {{#isSingleton}}
            form.append('{{&name}}', formParam['{{&name}}'] as string);
        {{/isSingleton}}
        {{^isSingleton}}
            typeof formParam['{{&name}}'] === 'function' && form.append('{{&name}}', (formParam['{{&name}}'] as Function)(parameters));
        {{/isSingleton}}
    {{/isFormParameter}}

{{/parameters}}

        if ($queryParameters && Object.keys($queryParameters).length) {
            Object.entries($queryParameters)
                .forEach(([$key, $param]) => {
                    // not sure why he doesn't know that $param should be a string
                    sp.set($key, $param as string);
                })
        }

        // for some odd reason does searchParams prefer value over it's name (key)
        url.searchParams.forEach((value, name) => {
            form.append(name, value);
        });

        // url.search = '';

    let hasForm = false;

    if((form as any).keys) {
        (form as any).keys().next(({value, done}) => value ? hasForm = true : void 0);
    } else {
        hasForm = !!form.getLengthSync();
    }

    if(hasForm) {
        body = form;
    }

    this.request<{{&responseTypes}}>(method, {{&model}} , url.toString(), body, headers, reject, resolve);
});
}
