// tslint:disable

{{#imports}}
/// <reference path="{{&.}}" />
{{/imports}}

import fetch, { Request, Response, Headers } from "node-fetch";
import FormData from 'form-data';

export type RequestHeaders = {
    [header: string]: string;
}

export type RequestHeadersHandler = (headers: Headers) => Headers;

export type ConfigureRequestHandler = (agent: Request) => Request;

export type CallbackHandler = (err: any, res?: Response) => void;

abstract class Model<T> {
    constructor(values: Partial<T>) {
        Object.entries(values)
            .map(([key, value]) => this[key] = value);
    }
}

{{#definitions}}

    {{#isClass}}
        export interface I{{&name}}
            {{#tsType}}{{> type}}{{/tsType}}

        class {{&name}}Model extends Model<I{{&name}}>
            {{#tsType}}{{> type}}{{/tsType}}

        export class {{&name}} extends {{&name}}Model {
            constructor(values?) {
                super(values);
            }
        }
    {{/isClass}}
    {{^isClass}}
        export type {{&name}} = {{#tsType}}{{> type}}{{/tsType}};
    {{/isClass}}
{{/definitions}}

export type Logger = { log: (line: string) => any };


export interface ResponseWithBody<S extends number, T> {
    readonly headers: Headers;
    readonly ok: boolean;
    readonly redirected: boolean;
    readonly status: S;
    readonly statusText: string;
    readonly trailer: Promise<Headers>;
    readonly type: ResponseType;
    readonly url: string;
    readonly body: T;
    readonly bodyUsed: boolean;
    clone (): SwaggerResponse<T>;
}

class SwaggerResponse<T> implements ResponseWithBody<number, T> {
    headers: Headers;
    ok: boolean;
    redirected: boolean;
    status: number;
    statusText: string;
    trailer: Promise<Headers>;
    type: ResponseType;
    url: string;
    body: T;
    bodyUsed: boolean;

    constructor(response: Response | SwaggerResponse<T>) {
        this.body = response.body as T;
        this.bodyUsed = response.bodyUsed;
        this.headers = response.headers;
        this.ok = response.ok;
        this.redirected = response.redirected;
        this.status = response.status;
        this.statusText = response.statusText;
        this.type = response.type;
        this.url = response.url;
    }

    clone () {
        return new SwaggerResponse<T>(this);
    }
}


export interface CommonRequestOptions {
  $queryParameters?: {[param: string]: any};
  $domain?: string;
  $path?: string | ((path: string) => string);
}

type Definition = {
    path: string,
    method: string,
    callable: (ctx: {{&className}}) => (parameters: {[k:string]: any}) => Promise<any>,
    params: {
        [k: string]: RegExp | string | ((p: { [k: string]: any }) => string)
    },
    headers: {[k:string]: string},
    body?: (p: {[k:string]:any}) => string,
    form?: {
        [k: string]: string | ((p: { [k: string]: any }) => string)
    },
    required?: string[]
}

/**
 * {{&description}}
 * @class {{&className}}
 * @param {(string)} [domainOrOptions] - The project domain.
 */
export class {{&className}} {

    private domain: string = "{{&domain}}";
    private errorHandlers: CallbackHandler[] = [];
    private requestHeadersHandler?: RequestHeadersHandler;
    private configureRequestHandler?: ConfigureRequestHandler;

    private static readonly entries: {[k:number]: Definition} = {
        {{#methods}}
            {{> map}}
        {{/methods}}
    };

    private static readonly idMapping: {[k: string]: number[]} = (() => {
        const ids = [
        {{#methods}}
            ['{{&path}}', {{position}}],
        {{/methods}}
        ];

        let mapping = {};
        ids
            .map(([path, position]) => [(path as string).toLowerCase(), position])
            .map(([path, position]) =>
                mapping[path] ?
                mapping[path].push(position) : mapping[path] = [position]
            );

        return mapping;
    })();

    constructor(domain?: string, private logger?: Logger) {
        if(domain) {
            this.domain = domain;
        }
    }

    isUnexpected(errorMessage, reject?) {
        const error = new Error('Unexpected Internal Error: ' + errorMessage);
        if(reject) {
            reject(error);
        } else {
            throw error;
        }
    }

    getDomain() {
        return this.domain;
    }

    addErrorHandler(handler: CallbackHandler) {
        this.errorHandlers.push(handler);
    }

    setRequestHeadersHandler(handler: RequestHeadersHandler) {
        this.requestHeadersHandler = handler;
    }

    setConfigureRequestHandler(handler: ConfigureRequestHandler) {
        this.configureRequestHandler = handler;
    }

/**
 * Helper function that will resolve the given URL to the connecting method to execute with.
 * You can further specify what definitive endpoint you want by providing a `method`.
 * @param {(string)} [url] - Case sensitive URL to look foor
 * @param {(string)} [method] - The Method you want to execute with
 * @return {function|function[]|null} - This function tries really hard to give you only **one** result, but it _may_ return a list - depending on `method`
 */
    getMethodForUrl(url: string, method?: string) {
        if(!/^\//.test(url)) {
            url = '/' + url;
        }

        const candidates = {{&className}}.idMapping[url.toLowerCase()];
        let resolvableIds = candidates

        if(method) {
            resolvableIds = candidates.filter((candidateId) => {
                const definition = {{&className}}.entries[candidateId];
                return definition.method === method;
            })
        }

        if(!resolvableIds) {
            throw new Error('Impossible to resolve that URL. Black Magic!');
        }

        const resolved = resolvableIds.map(id => {{&className}}.entries[id].callable(this).bind(this));

        if(resolved.length === 1) {
            return resolved[0];
        } else {
            // shouldn't happend, but theoratically...
            return resolved;
        }

    }

    private request<T>(method: string, model: any, url: string, body: any, headers: Headers, reject: CallbackHandler, resolve: CallbackHandler) {
        if(this.logger) {
            this.logger.log(`Call ${method} ${url}`);
        }

        if(body && Object.keys(body).length) {
            if(typeof(body) === 'object' && !headers['Content-Type']) {
                headers.set('Content-Type', 'application/json');
            }
        }

        if (this.requestHeadersHandler) {
            headers = this.requestHeadersHandler(headers);
        }

        let req = new Request(url, {
            method,
            headers,
            body
        });

        if (this.configureRequestHandler) {
            req = this.configureRequestHandler(req);
        }

        fetch(req).then((response) => {
            if(!response.ok) {
                // if no error, but response not ok, hope that the body contains details
                const error = new Error('Response status not OK: ' + response.status + ' ' + response.statusText);

                this.errorHandlers.forEach(handler => handler(error));
                reject(error);
            } else {
                const acceptedJson = /application\/json/.test(headers.get('Accept'));
                const derivedResponse = new SwaggerResponse<T>(response);

                if(response.status === 204) {
                    response.text().then(parsed => {
                        derivedResponse.body = parsed
                        derivedResponse.bodyUsed = true
                        resolve(derivedResponse);
                    });
                } else if (acceptedJson) {
                    response.json().then(parsed => {
                        let newBody = parsed;

                        if(model) {
                            if(parsed instanceof Array) {
                                newBody = parsed.map(item => new model(item));
                            } else {
                                newBody = new model(parsed);
                            }
                        }

                        derivedResponse.body = newBody
                        derivedResponse.bodyUsed = true
                        resolve(derivedResponse);
                    });
                } else {
                    resolve(derivedResponse);
                }
            }
        }).catch((err) => {
            this.errorHandlers.forEach(handler => handler(err));
            reject(err)
        })
    }

{{#methods}}
    {{> method}}
{{/methods}}
}

export default {{&className}};
